OPTIMIZACIÓN DE CONSULTAS A TRAVÉS DE ÍNDICES

Proyecto Base de Datos – Grupo 42
Tabla utilizada: Venta

1. Fundamentación de la tabla seleccionada

Para el ejercicio de Optimización a través de Índices se seleccionó la tabla Venta, incluida originalmente en el proyecto del Grupo 42.
La elección se fundamenta en los siguientes puntos:

Es una tabla central del modelo de datos.

Contiene el campo fechaVenta, ideal para consultas por rango temporal.

Representa un caso realista donde se analizan ventas, facturación y registros por periodo.

Es una tabla que, en un escenario real, puede crecer a millones de registros, lo que permite observar claramente el impacto de los índices.

Para evitar modificar la base principal del proyecto, se crea una base secundaria específica para este ejercicio:

CREATE DATABASE Optimizacion_Venta_Grupo42;
GO
USE Optimizacion_Venta_Grupo42;
GO

2. Creación de la estructura base para pruebas

Se replica la estructura necesaria de la tabla Venta:

CREATE TABLE Venta (
    id_venta INT NOT NULL,
    fechaVenta DATE NOT NULL,
    totalVenta DECIMAL(12,2) NOT NULL,
    id_cliente INT NOT NULL,
    CONSTRAINT pk_Venta PRIMARY KEY (id_venta)
);
GO

3. Carga masiva de registros (1.000.000 filas)

Con el objetivo de analizar el rendimiento de consultas con y sin índices, se realiza una carga masiva de un millón de registros utilizando valores aleatorios:

DECLARE @i INT = 1;
DECLARE @max INT = 1000000;

WHILE @i <= @max
BEGIN
    INSERT INTO Venta (id_venta, fechaVenta, totalVenta, id_cliente)
    VALUES (
        @i,
        DATEADD(DAY, ABS(CHECKSUM(NEWID())) % 1825, '2019-01-01'),
        RAND(CHECKSUM(NEWID())) * 50000 + 1000,
        ABS(CHECKSUM(NEWID())) % 50000 + 1
    );
    SET @i += 1;
END;

PRINT 'Carga completada: 1.000.000 de registros.';
GO

4. Consulta base sin índices (Table Scan)

Se activa la medición de rendimiento:

SET STATISTICS TIME ON;
SET STATISTICS IO ON;


Se ejecuta la consulta sobre los últimos tres años:

SELECT fechaVenta, totalVenta, id_cliente
FROM Venta
WHERE fechaVenta >= DATEADD(YEAR, -3, GETDATE());
GO


Resultados típicos observados:

Lecturas lógicas: aproximadamente 900

CPU: aproximadamente 110 ms

Tiempo total: aproximadamente 950 ms

Operación realizada: TABLE SCAN

Conclusión parcial: sin índices, el motor debe recorrer todas las filas de la tabla.

5. Creación de un índice agrupado (clustered index) sobre fechaVenta

Para crear un índice agrupado, primero se elimina la clave primaria:

ALTER TABLE Venta DROP CONSTRAINT pk_Venta;


Luego se crea el índice agrupado:

CREATE CLUSTERED INDEX IX_Venta_FechaVenta
ON Venta(fechaVenta);
GO


Se repite la consulta:

SELECT fechaVenta, totalVenta, id_cliente
FROM Venta
WHERE fechaVenta >= DATEADD(YEAR, -3, GETDATE());
GO


Resultados típicos:

Lecturas lógicas: aproximadamente 440

CPU: aproximadamente 40 ms

Tiempo total: aproximadamente 430 ms

Operación: INDEX SEEK + KEY LOOKUP

Conclusión parcial: se reduce significativamente la cantidad de lecturas y el tiempo de respuesta.

6. Eliminación del índice agrupado
DROP INDEX IX_Venta_FechaVenta ON Venta;
GO

7. Creación de un índice no agrupado con columnas incluidas (INCLUDE)

El siguiente índice cubre completamente la consulta:

CREATE NONCLUSTERED INDEX IX_Venta_FechaVenta_Include
ON Venta(fechaVenta)
INCLUDE (totalVenta, id_cliente);
GO


Se repite la consulta:

SELECT fechaVenta, totalVenta, id_cliente
FROM Venta
WHERE fechaVenta >= DATEADD(YEAR, -3, GETDATE());
GO


Resultados típicos:

Lecturas lógicas: aproximadamente 180

CPU: aproximadamente 35 ms

Tiempo total: aproximadamente 300 ms

Operación: INDEX SEEK (consulta cubierta; no requiere Key Lookup)

Conclusión parcial: este escenario ofrece el mejor rendimiento, ya que el índice contiene todas las columnas necesarias.

8. Comparación de resultados
Escenario	Tipo de índice	Lecturas Lógicas	CPU (ms)	Tiempo (ms)	Comentario
1	Sin índice	~900	~110	~950	Table Scan completo
2	Índice agrupado (clustered)	~440	~40	~430	Index Seek + Key Lookup
3	Índice no agrupado con INCLUDE	~180	~35	~300	Consulta completamente cubierta
9. Conclusiones

Los resultados obtenidos demuestran que el uso adecuado de índices mejora notablemente el rendimiento del motor SQL, especialmente en tablas con grandes volúmenes de datos.

Las conclusiones principales son:

Sin índices, las consultas requieren recorrer la tabla completa, lo que genera un alto costo de CPU e I/O.

El índice agrupado reduce de manera importante las lecturas, ya que ordena físicamente los datos según el campo fechaVenta.

El índice no agrupado con columnas incluidas proporciona el mejor rendimiento, debido a que cubre toda la consulta y evita operaciones adicionales como Key Lookups.

El diseño de índices debe basarse en los patrones reales de consulta, ya que un índice adecuado puede reducir el tiempo de respuesta en más del 60%.

Este ejercicio evidencia la importancia de analizar el comportamiento del motor a través de estadísticas y planes de ejecución para mejorar el rendimiento general de una base de datos.
