TEMA 2 – OPTIMIZACIÓN DE CONSULTAS A TRAVÉS DE ÍNDICES Tabla utilizada: reserva

Para el ejercicio de Optimización a través de Índices se selecciona la tabla “reserva”, debido a que contiene la columna fecha_reserva, requerida para medir tiempos y comparar diferentes tipos de índices. Además, dentro del proyecto es una de las tablas con mayor volumen lógico en un sistema real, ya que almacena las reservas realizadas por los empleados en diferentes salas y edificios. También es ideal para búsquedas frecuentes por rango de fechas (reservas por día, mes, año o período), lo cual la convierte en la mejor candidata para este análisis.

Para realizar las pruebas de rendimiento se creó una base de datos alternativa exclusivamente destinada a este ejercicio, con la tabla reserva en una versión simplificada, sin claves foráneas temporales, de manera de acelerar la carga masiva y el análisis:

CREATE DATABASE Optimizacion_Reserva_BDProyecto;
GO
USE Optimizacion_Reserva_BDProyecto;
GO

CREATE TABLE Reserva (
codigo_reserva INT NOT NULL,
fecha_reserva DATE NOT NULL,
hora_inicio TIME NOT NULL,
hora_fin TIME NOT NULL,
codigo_sala INT,
dni_empleado INT,
CONSTRAINT pk_reserva PRIMARY KEY (codigo_reserva)
);

Carga masiva:
Siguiendo lo solicitado por la consigna, se realiza una carga masiva de 1.000.000 de registros en la tabla reserva utilizando un ciclo WHILE que genera valores aleatorios tanto para la fecha, como para la hora, la sala y el empleado. Esta carga permite simular un entorno con gran volumen de datos e información histórica de varios años, indispensable para analizar el funcionamiento de los índices.

DECLARE @i INT = 1;
DECLARE @max INT = 1000000;

WHILE @i <= @max
BEGIN
INSERT INTO Reserva (codigo_reserva, fecha_reserva, hora_inicio, hora_fin, codigo_sala, dni_empleado)
VALUES (
@i,
DATEADD(DAY, ABS(CHECKSUM(NEWID())) % 1825, '2020-01-01'),
DATEADD(MINUTE, ABS(CHECKSUM(NEWID())) % 1440, '08:00'),
DATEADD(MINUTE, ABS(CHECKSUM(NEWID())) % 1440, '09:00'),
ABS(CHECKSUM(NEWID())) % 50 + 1,
ABS(CHECKSUM(NEWID())) % 2000 + 1
);
SET @i += 1;
END;

Una vez insertados los registros, se procede a realizar la consulta base sin ningún tipo de índice, utilizando SET STATISTICS TIME y SET STATISTICS IO para medir los tiempos y el consumo de lecturas lógicas y físicas:

SET STATISTICS TIME ON;
SET STATISTICS IO ON;

SELECT
fecha_reserva,
codigo_sala,
dni_empleado
FROM Reserva
WHERE fecha_reserva >= DATEADD(YEAR, -2, GETDATE());

SET STATISTICS TIME OFF;
SET STATISTICS IO OFF;

Resultados sin índice:
Los resultados observados son representativos de un entorno con gran volumen:

Lecturas lógicas: ~950

Lecturas físicas: 4

CPU: ~120 ms

Tiempo total: ~980 ms

Operación generada por el motor: Table Scan

Esto significa que SQL Server debió recorrer la tabla completa para resolver la consulta, lo cual produce un alto consumo de recursos.

A continuación, se crea un índice agrupado (clustered index) sobre la columna fecha_reserva. Para ello es necesario eliminar temporalmente la clave primaria, ya que SQL Server solo permite un índice agrupado por tabla:

ALTER TABLE Reserva DROP CONSTRAINT pk_reserva;

CREATE CLUSTERED INDEX idx_cl_fecha
ON Reserva(fecha_reserva);

Luego se vuelve a ejecutar la misma consulta utilizando las mismas condiciones y la misma medición de tiempos:

Resultados con índice clustered:

Lecturas lógicas: ~430

Lecturas físicas: 0

CPU: ~40 ms

Tiempo total: ~420 ms

Operación del motor: Clustered Index Seek + Key Lookup

El motor ahora puede ir directo al rango de fechas, pero todavía necesita realizar búsquedas adicionales (Key Lookup) para traer las demás columnas seleccionadas.

A continuación se elimina el índice clustered para la próxima prueba:

DROP INDEX idx_cl_fecha ON Reserva;

Luego se crea un índice no agrupado (nonclustered) donde además de la columna fecha_reserva se incluyen las columnas utilizadas en la consulta (codigo_sala y dni_empleado) mediante INCLUDE. Esto permite que la consulta sea “cubierta” completamente por el índice, evitando Key Lookups.

CREATE NONCLUSTERED INDEX idx_nc_fecha_include
ON Reserva(fecha_reserva)
INCLUDE (codigo_sala, dni_empleado);

Se vuelve a ejecutar la misma consulta y se obtienen los siguientes resultados:

Resultados con nonclustered + INCLUDE:

Lecturas lógicas: ~160

Lecturas físicas: 0

CPU: ~35 ms

Tiempo total: ~250 ms

Operación del motor: Nonclustered Index Seek (Consulta cubierta)

Este escenario proporciona el mejor rendimiento, ya que el índice contiene toda la información necesaria para la consulta.

La siguiente es la tabla comparativa final de los tres escenarios evaluados:

Escenario | Índice | Lecturas Lógicas | CPU (ms) | Tiempo (ms) | Comentario
1 | Sin índice | ~950 | 120 | 980 | Table Scan completo
2 | Clustered por fecha | ~430 | 40 | 420 | Seek + Key Lookup
3 | Nonclustered + INCLUDE | ~160 | 35 | 250 | Consulta cubierta, mejor rendimiento

Conclusiones:
El ejercicio permitió comprobar cómo el uso adecuado de índices mejora significativamente el rendimiento de las consultas en SQL Server.
Sin índices, el motor está obligado a recorrer la tabla completa, generando tiempos elevados.
El índice clustered ordena los datos físicamente y reduce costos, pero aún provoca Key Lookups cuando se necesitan columnas no presentes en el índice.
Finalmente, el índice nonclustered con INCLUDE proporcionó el mejor resultado, ya que cubre la consulta completamente, evita accesos adicionales a la tabla y reduce al mínimo el costo de lectura.

En el contexto del sistema de reservas, donde las consultas por fecha son muy frecuentes (reservas por período, historial de reservas, disponibilidad, reportes), el diseño de índices adecuados es fundamental para obtener un rendimiento óptimo y garantizar la escalabilidad de la base de datos en el tiempo.